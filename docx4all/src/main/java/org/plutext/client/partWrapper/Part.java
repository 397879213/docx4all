package org.plutext.client.partWrapper;

import java.util.List;

import org.apache.log4j.Logger;
import org.docx4j.openpackaging.parts.JaxbXmlPart;
import org.plutext.client.Mediator;

public class Part {
	
	
	private static Logger log = Logger.getLogger(Part.class);

	/*
	 * We need to be able to create this Part wrapper from:
	 * 
	 * 1.  an string of xml for serverSequencedParts, since this is 
	 * 	   what we get from the server.
	 * 
	 * 2.  a JaxbXmlPart, since this is what we have when
	 *     we extractParts from the local document
	 *     
	 * In the Word Add-In, we operate at the XML DOM level.
	 * 
	 * In docx4all, we could operate at the XML DOM level, or
	 * potentially at the JAXB level.
	 * The problem with operating at the JAXB level is that
	 * we have:
	 *     List<Comments.Comment>
	 *     List<CTFtnEdn> footnote;
	 *     List<Relationship> relationship;
	 * Whilst I can handle all these as List<Object>, I need to 
	 * be able to use comment.setId(BigInteger), rel.setId(String)
	 * methods, which I think I could do via reflection.
	 * 
	 * But all things considered, its better to keep the
	 * code similar to the Word Add-In, so that means
	 * XML DOM level. 
	 */
	
	
	// Handle XML String we get from the server
    public static Part factory(String partXml)
    {
        XmlDocument partDoc = new XmlDocument();
        partDoc.LoadXml(partXml);
        XmlNamespaceManager nsmgr = new XmlNamespaceManager(partDoc.NameTable);
        nsmgr.AddNamespace("w", Namespaces.WORDML_NAMESPACE);

        return factory(partDoc.DocumentElement);
    }

    public static Part factory(org.docx4j.openpackaging.parts.Part docx4jPart)
    {
        // Somewhere, we need to (un?)marshal JaxbXmlPart
    	
        return factory(partDoc.DocumentElement);
    }
    

    public static Part factory(XmlNode xmlNode)
    {
    	/* TODO - use jaxp
    	 * 
    	 */
    	
    	
    	
        log.Debug("documentElemnet: " + xmlNode.Name);

        String name = xmlNode.Attributes.GetNamedItem("name", Namespaces.PKG_NAMESPACE).Value;

        log.debug("part: " + name );

        if (name.equals("/word/_rels/document.xml.rels"))
        {
            return new SequencedPartRels(jxp);
        }
        else if (name.equals("/word/footnotes.xml")
                    | name.equals("/word/endnotes.xml")
                    | name.equals("/word/comments.xml"))
        {
            return new SequencedPart(jxp);
        } else if (name.startsWith("/customXml") )
        {
//            XmlNode n = xmlNode.FirstChild.FirstChild;
//            log.Debug("customXml contains: " + n.Name);

            // 2009 03 03, this is now gone by the time this runs

            //if (n.Name.Equals("parts"))
            //{
            //    log.Debug("Got it! " );
            //    return new PartVersionList(xmlNode);
            //}
            //else
            //{
                return new Part(jxp);
            //}
        } else 
        {
            return new Part(jxp);
        } 
    }

    public Part()
    { }

    public Part(JaxbXmlPart jxp)
    {
        init(jxp);
    }

    public void init(JaxbXmlPart jxp)
    {
        /*
         * <pkg:part pkg:name="/_rels/.rels" pkg:contentType="application/vnd.openxmlformats-package.relationships+xml" pkg:padding="512">
         * 
         * <pkg:part pkg:name="/word/_rels/document.xml.rels" pkg:contentType="application/vnd.openxmlformats-package.relationships+xml"
         * 
         * <pkg:part pkg:name="/word/document.xml" pkg:contentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml">
         */
    	
    	this.jxp = jxp;

        // Record XML for the purposes of detecting changes we 
        // may have to transmit.  Note that although fetching updates
        // can create a Part object out of XML sent by the
        // server, the Part objects examined in transmission
        // are each generated by Word.  (And in any case, the
        // ones sent by the server are never marshalled/unmarshalled
        // as at 2008 12 18)
//        xml = xmlNode.OuterXml;
//
//        // pkg:part/pkg:xmlData/ZZZ, where ZZZ is what we
//        // want to be able to transmit to the server
//        unwrappedXml = xmlNode.FirstChild.FirstChild.OuterXml;
//
//        this.xmlNode = xmlNode;
//
//        name = xmlNode.Attributes.GetNamedItem("name", Namespaces.PKG_NAMESPACE).Value;
//        contentType = xmlNode.Attributes.GetNamedItem("contentType", Namespaces.PKG_NAMESPACE).Value;

    }
    
    JaxbXmlPart jxp;

//    // Reference to original node.
//    // Not of any use if the constructor took a string rather than the node!
//    protected XmlNode xmlNode;
//    public XmlNode XmlNode
//    {
//        get { return xmlNode; }
//    }
//
//    private String xml = null;
//    public String Xml
//    {
//        get { return xml; }
//        set { xml = value; }
//    }
//
//    // pkg:part/pkg:xmlData/ZZZ, where ZZZ is what we
//    // want to be able to transmit to the server;
//    // or pkg:part/pkg:binaryData/ZZZ
//    // Hmm, better if we send the xmlData|binaryData
//    // node?  No, since then we have to strip that tag.
//    private String unwrappedXml = null;
//    public String UnwrappedXml
//    {
//        get { return unwrappedXml; }
//        set { unwrappedXml = value; }
//    }
//
//
//    protected string name;
      public String getName() {
    	  return jxp.getPartName().getName();
      }
//    public string Name
//    {
//        get { return name; }
//        set { name = value; }
//    }
//
//    protected string contentType;
//    public string ContentType
//    {
//        get { return contentType; }
//        set { contentType = value; }
//    }


}
